unit wProjExemplo;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;

type
  TForm44 = class(TForm)
    Memo1: TMemo;
    Button1: TButton;
    procedure Button1Click(Sender: TObject);
  private
    procedure add(s: String);
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form44: TForm44;

implementation

{$R *.dfm}

uses System.SyncObjs, System.Threading;

procedure TForm44.add(s: String);
begin
  TThread.Queue(TThread.CurrentThread,
    procedure
    begin
      Memo1.lines.add(s);
    end);
end;

Type
  TTaskHelper = class helper for TTask
  private type
    TUnsafeTaskEx = record
    private
      [Unsafe]
      // preciso de um record UNSAFE para nao incrementar o RefCount da Interface
      FTask: TTask;
    public
      property Value: TTask read FTask write FTask;
    end;
  public
    class function WaitForAllEx(AArray: Array of ITask;
    ATimeOut: int64 = INFINITE):boolean;
  end;

class function TTaskHelper.WaitForAllEx(AArray: array of ITask;
ATimeOut: int64 = INFINITE):boolean;
var
  task: TUnsafeTaskEx;
  i: integer;
  taskInter: TArray<TUnsafeTaskEx>;
  // CompleteProc: TProc<ITask>;
  completou: boolean;
  // FEvent: TEvent;
  Canceled, Exceptions: boolean;
begin
  Canceled := false;
  Exceptions := false;
  result := true;
  for i := low(AArray) to High(AArray) do
  begin
    task.Value := TTask(AArray[i]);
    if task.Value = nil then
      raise EArgumentNilException.Create('Wait Nil Task');

    completou := task.Value.IsComplete;
    if not completou then
    begin
      taskInter := taskInter + [task];
    end
    else
    begin
      if task.Value.HasExceptions then
        Exceptions := True
      else if task.Value.IsCanceled then
        Canceled := True;
    end;
  end;

  { CompleteProc := procedure(ATask: ITask)
    begin
    FEvent.SetEvent;
    end;
    FEvent := TEvent.Create();
  } try
    for task in taskInter do
    begin
      while not task.Value.IsComplete do
      begin
        try
          TThread.Queue(nil,
            procedure
            begin
              application.ProcessMessages;
            end);
        finally
        end;
      end;
      if task.Value.IsComplete then
      begin
        if task.Value.HasExceptions then
          Exceptions := True
        else if task.Value.IsCanceled then
          Canceled := True;
        result := result and not (Exceptions or Canceled);
      end;
    end;
  finally
    // FEvent.Free;
  end;

  if not Result or (not Exceptions and not Cancelled) then
    Exit;
  if Exceptions or Canceled then
    raise EOperationCancelled.CreateRes('One Or More Tasks HasExceptions/Canceled');

end;

procedure TForm44.Button1Click(Sender: TObject);
var
  tsk: array [0 .. 2] of ITask;
  i, n: integer;
begin
  tsk[0] := TTask.Create(
    procedure
    begin
      TThread.Queue(nil,
        procedure
        begin
          caption := 'xxx'; // sincronizar a atualização da janela.
        end);
    end);
  tsk[0].Start;

  tsk[2] := TTask.Create(
    procedure
    var
      k: integer;
    begin
      i := 1;
      Sleep(10000);
      for k := 0 to 10000 do
        inc(i);
    end);

  tsk[1] := TTask.Create(
    procedure
    var
      k: integer;
    begin
      n := n;
      for k := 0 to 1000 do
        inc(n);
      add('N');
    end);

  tsk[2].Start;
  tsk[1].Start;

  TTask.WaitForAllEx(tsk, 90000000);

  Memo1.lines.add('xxxxxxxx N: ' + IntToStr(n) + ' I: ' + IntToStr(i));

  TParallel.For(100, 105,
    procedure(i: integer)
    begin
      add(IntToStr(i));
    end);

  Memo1.lines.add(' N: ' + IntToStr(n) + ' I: ' + IntToStr(i));

end;

{ TTaskHelper }

end.
